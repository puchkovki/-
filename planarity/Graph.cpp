//#include "Graph.h"
#include <iostream>
// #include <vector>
//#include <iterator>
// #include <map>
#include <utility>
using namespace std;


/*Для плоской укладки графа и попутной проверки, планарен ли он, удобно пользоваться гамма-алгоритмом.
На вход подаются графы, обладающие следующими свойствами:
1) граф связный;
2) граф имеет хотя бы один цикл;
3) граф не имеет мостиков, т. е. ребер, после удаления которых граф распадается на две компонеты связности.

Если нарушено свойство (1), то граф нужно укладывать отдельно по компонентам связности. 

Если нарушено свойство (2), то граф — дерево и нарисовать его плоскую укладку тривиально.

Случай нарушения свойства (3) рассмотрим более подробно. Если в графе есть мостики, то их нужно разрезать, провести отдельно плоскую укладку каждой компоненты связности, а затем соединить их мостиками. Здесь может возникнуть трудность: в процессе укладки концевые вершины мостика могут спрятаться внутри плоского графа. Нарисуем одну компоненту связности и будем присоединять к ней другие последовательно. Каждую новую компоненту связности будем рисовать в той грани, в которой лежит концевая вершина соответствующего мостика. Так как граф связности мостиками компонент связности является деревом, мы сумеем получить плоскую укладку.*/

int main(void) {
    cout << "Введите ваш граф в следующем формате: кол-во вершин, кол-во ребер и их их последовательное описание (e_1, e_2)" << endl;
    
    int vertex_capacity, edges_capacity = 0;

    cin >> vertex_capacity >> edges_capacity;

    int e_1, e_2;

    size_t matrix[vertex_capacity][vertex_capacity];

    for (int i = 0; i < edges_capacity; i+=2) {
        cin >> e_1 >> e_2;
        matrix[e_1][e_2] +=1;
        matrix[e_2][e_1] +=1;
    } 
    //Для простого, связного планарного графа с v вершинами и e ребрами, следующие простые критерии планарности держать
    if ((vertex_capacity >= 3) && (edges_capacity > 3*vertex_capacity - 6)) {
        cout << "Ваш граф непланарен."
    }

    

    cout << vertex_capacity << edges_capacity;
    
    cout << endl;
}